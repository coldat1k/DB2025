#  Лабораторна робота 4: Аналітичні SQL-запити (OLAP)

## 1. Базова агрегація (COUNT, SUM, AVG, MIN, MAX)

Ці запити використовуються для отримання швидкої зведеної статистики з однієї таблиці.

### 1.1. Загальна кількість клієнтів
* **Що робить:** Підраховує загальну кількість записів у таблиці `CUSTOMER`.
* **Навіщо:** Для отримання базової метрики - скільки клієнтів зареєстровано в системі.
* **Функція:** `COUNT(*)`

### 1.2. Загальна сума всіх бронювань
* **Що робить:** Обчислює суму всіх значень у стовпці `total_amount` таблиці `BOOKING`.
* **Навіщо:** Для визначення загального доходу від усіх бронювань.
* **Функція:** `SUM()`

### 1.3. Середня тривалість фільмів
* **Що робить:** Розраховує середнє арифметичне тривалості всіх фільмів (стовпець `duration` у `MOVIE`).
* **Навіщо:** Для аналізу середньої довжини фільмів у прокаті.
* **Функція:** `AVG()`

### 1.4. Максимальна та мінімальна вартість квитка
* **Що робить:** Знаходить найвищу (`MAX`) та найнижчу (`MIN`) ціну квитка у таблиці `TICKET`.
* **Навіщо:** Для визначення діапазону цін на квитки в кінотеатрі.
* **Функції:** `MAX()`, `MIN()`

---

## 2. Групування даних (GROUP BY)

Ці запити агрегують дані, групуючи їх за певним критерієм.

### 2.1. Кількість місць у кожному залі
* **Що робить:** Об'єднує `HALL` та `SEAT` і підраховує місткість (`COUNT(seat_id)`) кожного залу (`name_hall`).
* **Навіщо:** Для порівняння місткості різних залів.
* **Групування:** `GROUP BY h.name_hall`

### 2.2. Загальна сума бронювань для кожного клієнта
* **Що робить:** Групує бронювання (`BOOKING`) за клієнтами (`CUSTOMER`) та підсумовує їх витрати (`total_amount`).
* **Навіщо:** Для аналізу лояльності клієнтів та їх витрат.
* **Групування:** `GROUP BY c.full_name`

### 2.3. Кількість фільмів за жанрами
* **Що робить:** Підраховує кількість фільмів (`COUNT(movie_id)`) у таблиці `MOVIE`, групуючи їх за значенням стовпця `genre`.
* **Навіщо:** Для визначення поширеності різних жанрів у прокаті.
* **Групування:** `GROUP BY genre`

---

## 3. Фільтрування груп (HAVING)

Ці запити фільтрують результати, отримані після агрегації (`GROUP BY`), за допомогою `HAVING`.

### 3.1. Клієнти, які витратили більше 200 грн
* **Що робить:** Вибирає клієнтів, сумарні витрати (`SUM(b.total_amount)`) яких перевищують 200 грн.
* **Навіщо:** Для визначення найбільш цінних клієнтів (VIP).
* **Фільтрація груп:** `HAVING SUM(b.total_amount) > 200`

### 3.2. Зали з більше ніж 1 сеансом
* **Що робить:** Знаходить зали, в яких заплановано більше одного сеансу (`COUNT(s.session_id)`).
* **Навіщо:** Для виявлення найбільш завантажених залів.
* **Фільтрація груп:** `HAVING COUNT(s.session_id) > 1`

---

## 4. Операції JOIN (Об'єднання даних)

Ці запити демонструють використання різних типів операцій об'єднання.

### 4.1. INNER JOIN: Детальна інформація про сеанси
* **Що робить:** Об'єднує `SHOWING`, `MOVIE` та `HALL` для відображення назви фільму, часу та типу зали, де відбудеться сеанс.
* **Навіщо:** Для отримання детальної інформації про заплановані сеанси.
* **Тип JOIN:** `INNER JOIN`

### 4.2. LEFT JOIN: Всі фільми та їхні сеанси
* **Що робить:** Показує всі фільми (`MOVIE`), навіть ті, які ще не мають запланованих сеансів (`SHOWING`).
* **Навіщо:** Для перегляду повного каталогу фільмів незалежно від поточного розкладу.
* **Тип JOIN:** `LEFT JOIN`

### 4.3. RIGHT JOIN: Усі квитки та інформація про клієнтів
* **Що робить:** Об'єднує `TICKET`, `BOOKING` та `CUSTOMER`. Фокусується на бронюваннях і клієнтах, щоб показати, хто саме купив квитки.
* **Навіщо:** Для аналізу продажів з прив'язкою до клієнтів.
* **Тип JOIN:** `RIGHT JOIN`

---

## 5. Запити з підзапитами (Subqueries)

Ці запити використовують результат одного `SELECT` всередині іншого запиту.

### 5.1. Підзапит у WHERE: Фільми, які показуються у залі певного типу
* **Що робить:** Вибирає назви фільмів, які мають сеанси в залі типу '3D'.
* **Навіщо:** Для фільтрації фільмів за технічними вимогами зали.
* **Розміщення підзапиту:** У умові `WHERE` (використовуючи `IN`).

### 5.2. Підзапит у SELECT: Кількість бронювань клієнта
* **Що робить:** Для кожного клієнта (`CUSTOMER`) додає стовпець, який обчислює та виводить кількість його бронювань (`BOOKING`).
* **Навіщо:** Для аналізу активності клієнтів без використання `GROUP BY`.
* **Розміщення підзапиту:** У вибірковому списку `SELECT`.

### 5.3. Підзапит у HAVING: Зали, де середня ціна квитка вища за загальну середню
* **Що робить:** Вибирає зали, де середня ціна квитка на сеанси в цій залі перевищує загальну середню ціну всіх квитків.
* **Навіщо:** Для порівняння цінової політики в окремих залах із середнім показником по кінотеатру.
* **Розміщення підзапиту:** У умові `HAVING`.

---

## 6. Багатотаблична агрегація (Запити, що об'єднують таблиці для агрегації)

Ці запити об'єднують кілька таблиць для отримання складних зведених звітів.

### 6.1. Загальний дохід від кожного фільму
* **Що робить:** Об'єднує `MOVIE`, `SHOWING` та `TICKET` і агрегує суму цін квитків (`SUM(price)`) по назвах фільмів.
* **Навіщо:** Для аналізу касових зборів по кожному фільму.
* **Складність:** 2 `JOIN` + `GROUP BY`

### 6.2. Кількість проданих квитків на кожен сеанс
* **Що робить:** Об'єднує `TICKET`, `SHOWING` та `MOVIE` і підраховує кількість квитків (`COUNT(ticket_id)`) для кожного сеансу.
* **Навіщо:** Для аналізу відвідуваності окремих сеансів.
* **Складність:** 2 `JOIN` + `GROUP BY`

### 6.3. Загальна виручка по залах
* **Що робить:** Об'єднує `HALL`, `SHOWING` та `TICKET` та агрегує виручку (`SUM(price)`) по кожному залу.
* **Навіщо:** Для оцінки ефективності використання залів.
* **Складність:** 2 `JOIN` + `GROUP BY`
